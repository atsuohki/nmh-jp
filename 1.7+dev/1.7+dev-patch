--- h/mh.h-ORIG	2021-05-17 07:43:21.000000000 +0900
+++ h/mh.h	2021-05-17 07:54:41.000000000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mh.h -- main header file for all of nmh
  */
 
@@ -432,5 +434,25 @@
 #ifndef abs
 # define abs(a) ((a) > 0 ? (a) : -(a))
 #endif
+
+/* iso-2022-jp escape sequences */
+#define JP7_SEQ		"\033$B"
+#define JP7_SEQ1	"\033$(B"
+#define JP7_ENDB	"\033(B"
+#define JP7_ENDJ	"\033(J"
+
+/* set `q' as pointing at the end sequence if `p' points at a start sequence */
+#define jp7_end_seq(p,q) (!strncmp(p,JP7_SEQ,3) && \
+			  ((q=strstr(p+3,JP7_ENDB)) || (q=strstr(p+3,JP7_ENDJ))) )
+
+#define jp7_end_seq1(p,q) (!strncmp(p,JP7_SEQ1,4) && \
+			   ((q=strstr(p+4,JP7_ENDB)) || (q=strstr(p+4,JP7_ENDJ))) )
+
+/* set `q' as pointing at a start sequence, searching from `p' */
+#define jp7_bgn_seq(p,q) ((q=strstr(p,JP7_SEQ)) && \
+			  (strstr(q+3,JP7_ENDB) || strstr(q+3,JP7_ENDJ)) )
+
+#define jp7_bgn_seq1(p,q) ((q=strstr(p,JP7_SEQ1)) && \
+			   (strstr(q+4,JP7_ENDB) || strstr(q+4,JP7_ENDJ)) )
 
 #define CTXMOD	0x01		/* context information modified */
--- mts/smtp/smtp.c-ORIG	2022-02-05 14:11:28.653213000 +0900
+++ mts/smtp/smtp.c	2022-02-05 14:11:28.691998000 +0900
@@ -19,6 +19,7 @@
 #include <sys/socket.h>
 #include <signal.h>
 #include "sbr/base64.h"
+#include <signal.h>
 
 /*
  * This module implements an interface to SendMail very similar
--- sbr/encode_rfc2047.c-ORIG	2022-02-27 10:16:28.224940000 +0900
+++ sbr/encode_rfc2047.c	2022-03-21 23:35:23.563049000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* encode_rfc2047.c -- encode message headers using RFC 2047 encoding.
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -14,6 +16,7 @@
 #include "utils.h"
 #include "base64.h"
 #include "unquote.h"
+#include "sbr/context_find.h"
 
 /*
  * List of headers that contain addresses and as a result require special
@@ -73,12 +76,20 @@
 {
     int i, asciicount = 0, eightbitcount = 0, qpspecialcount = 0;
     char *p;
+    bool has_iso_2022_jp = false;
 
     /*
      * First, check to see if we even need to encode the header
      */
 
     for (p = *value; *p != '\0'; p++) {
+	char *q;
+	if (jp7_end_seq(p, q) || jp7_end_seq1(p, q)) {
+	    eightbitcount += q + 3 - p;
+	    p = q + 3 - 1;
+	    has_iso_2022_jp = true;
+	    continue;
+	}
 	if (isascii((unsigned char) *p)) {
 	    asciicount++;
 	    if (qpspecial((unsigned char) *p))
@@ -87,6 +98,11 @@
 	    eightbitcount++;
     }
 
+    if (has_iso_2022_jp) {
+	charset = "iso-2022-jp";
+	encoding = CE_BASE64;
+    }
+
     if (eightbitcount == 0)
 	return 0;
 
@@ -311,7 +327,338 @@
     return 0;
 }
 
+static void
+expand_line(char **basepp, char **crntpp, char **endpp, int delta)
+{
+    /* allocate first time */
+    if (!(*basepp)) {
+	*basepp = *crntpp =  mh_xmalloc(delta);
+	*endpp = *basepp + delta;
+	*(*basepp) = 0;
+	return;
+    }
+    /* expand allocated region */
+    {   size_t length;
+
+	length = *endpp - *basepp;
+	*basepp = mh_xrealloc(*basepp, length + delta);
+	*crntpp = *basepp + strlen(*basepp);
+	*endpp = *basepp + length + delta;
+    }
+}
+
+static void
+new_line(char **basepp, char **linepp, char **crntpp, char **endpp, int delta, int plen)
+{
+    int i;
+
+    if (**crntpp)
+	adios(NULL, "Internal error: malformed string?");
+
+    delta -= *endpp - *crntpp;
+    if (delta > 0)
+	expand_line(basepp, crntpp, endpp, delta);
+    *(*crntpp)++ = '\n';
+    *(*crntpp) = 0;
+    *linepp = *crntpp;
+
+    for (i=0; i<plen; i++) *(*crntpp)++ = ' ';
+    *(*crntpp) = 0;
+}
+
+static char*
+skip_sp(char *p)
+{
+    while ( p && isspace((unsigned char) (*p)) ) p++;
+    return p;
+}
+
+#define JP7_PAIRS 128
+static struct {
+    char *bgn;	/* point at start of sequence */
+    char *end;  /* just beyond the sequence end */
+    int is4;
+    int isB;
+} jp7_pair[JP7_PAIRS];
+static int jp7_cnt;
+
+static char*
+token_end(char *p, int *jp7p, int *is8p, int build_jp7_pair)
+{
+    char c, *q;
+
+    if (!p) return p;
+
+    *jp7p = 0;
+    *is8p = 0;
+    if (build_jp7_pair)
+	jp7_cnt = 0;
+
+    /* start with `"' and end with `" ' or `"\0" */
+    if (*p == '"') {
+	char *r = p + 1;
+	while ((c = *r++) && c != '"') {
+	    if (jp7_end_seq(r-1, q) || jp7_end_seq1(r-1, q))
+		goto check;
+	    if (!isascii((unsigned char) c))
+		goto check;
+	}
+	if ( c == '"' && (*r == 0 || (isspace((unsigned char)(*r)))) )
+	    return r;
+    }
+
+ check:
+    while ((c = *p)) {
+	if (isspace((unsigned char) c)) break;
+	if ( (c == '\033') && (jp7_end_seq(p, q) || jp7_end_seq1(p, q)) ) {
+	    if (build_jp7_pair) {
+		if (jp7_cnt >= JP7_PAIRS) {
+		    inform(NULL, "Internal error: jp7_pair full");
+		    return NULL;
+		}
+		jp7_pair[jp7_cnt].bgn = p;
+		jp7_pair[jp7_cnt].is4 = !strncmp(p, JP7_SEQ1, 4);
+		jp7_pair[jp7_cnt].end = p = q + 3;
+		jp7_pair[jp7_cnt].isB = !strncmp(q, JP7_ENDB, 3);
+		if ((q - (jp7_pair[jp7_cnt].bgn + 3 + jp7_pair[jp7_cnt].is4)) % 2)
+		    inform("KANJI code not even number of bytes");
+		jp7_cnt++;
+	    } else
+		p = q + 3;
+	    (*jp7p)++;
+	    continue;
+	}
+	if (!isascii((unsigned char) c))
+	    (*is8p)++;
+	p++;
+    }
+
+    if (build_jp7_pair && *p && (*jp7p || *is8p) ) {
+	/* check if the next token should be encoded too */
+	char *s;
+	int jp7, is8;
+	s = skip_sp(p);
+	if (!token_end(s, &jp7, &is8, 0))
+	    return p;
+	if (jp7 || is8) {
+	    p = skip_sp(p);
+	    goto check; /* expand token end */
+	}
+    }
+
+    return p;
+}
+
+static int
+all_white(char *base, char *line, char *crnt)
+{
+    while (crnt > line && crnt > base) {
+	if (*--crnt == ' ') continue;
+	return 0;
+    }
+    return 1;
+}
+
 /*
+ * Encode our specified header (or field) using base64, token by token.
+ */
+
+static int
+field_encode_base64_atom_wise(const char *name, char **value, const char *charset)
+{
+    int prefixlen = name ? 2 : 0, charsetlen = strlen(charset);
+    int min64len = 2 + charsetlen + 3 + 0 + 2;
+    int outlen;
+    char *output = NULL, *linep = NULL, *crntp = NULL, *endp = NULL;
+    char *p = *value, *q;
+    int was_encoded;
+
+    /* skip leading spaces */
+    p = skip_sp(p);
+    /*
+     * If we had a zero-length prefix, then just encode the whole field
+     * as-is, without line wrapping.  Note that in addition to the encoding
+     *
+     * The added length we need is =? + charset + ?B? ... ?=
+     *
+     * That's 7 + strlen(charset) + 2 (for \n NUL).
+     */
+    if (!prefixlen) {
+	outlen = min64len + base64len(strlen(p)) + 2;
+	expand_line(&output, &crntp, &endp, outlen);
+	crntp += snprintf(crntp, endp - crntp, "=?%s?B?", charset);
+	if (writeBase64raw((unsigned char *) p, strlen(p),
+			   (unsigned char *) crntp) != OK) {
+	    inform("Internal error: base64 encoding of header failed");
+	}
+	strcat(crntp, "?=");
+	free(*value);
+	*value = output;
+	return 0;
+    }
+
+    /*
+     * Note ENCODELINELIMIT is + 2 because of \n \0
+     */
+    outlen = ENCODELINELIMIT + 2 - (strlen(name) + 2); /* first time */
+    expand_line(&output, &crntp, &endp, outlen);
+    linep = output - strlen(name) - 1; /* intentional! */
+    outlen = ENCODELINELIMIT + 2; /* second and afterward */
+    was_encoded = -1; /* previous token is encoded or not */
+
+#define left_in_ln (ENCODELINELIMIT - (crntp - linep))
+
+    while ((p = skip_sp(p)) && *p) {
+	int is8, jp7;
+	int l;
+	char *jp7savep, savedstr[5];
+	int is4, isB;
+	    
+	if (!(q = token_end(p, &jp7, &is8, 1)))
+	    return 1;
+	if (jp7 && is8) {
+	    inform("Error: iso-2022-jp and 8bit code?");
+	    return 1;
+	}
+	*crntp++ = ' '; *crntp = 0;
+
+	if (was_encoded > 0 && 
+	    (jp7 || is8 || q - p > ENCODELINELIMIT - prefixlen) ) {
+	    /* include seprating space */
+	    p--;
+	    was_encoded = -1;
+	}
+
+    cp_again:
+	l = (!jp7 && !is8)?( q - p ):( base64len(q - p) + min64len );
+	if (l <= left_in_ln) {
+	    /* fit in a remaing space */
+	    if (!jp7 && !is8) {
+		crntp = stpncpy(crntp, p, q - p);
+		*crntp = 0;
+		was_encoded = 0;
+	    } else {
+		crntp += snprintf(crntp, left_in_ln, "=?%s?B?", charset);
+		if (writeBase64raw((unsigned char *) p, q - p,
+				   (unsigned char *) crntp) != OK) {
+		    inform("Internal error: base64 encoding of header failed");
+		    return 1;
+		}
+		crntp += base64len(q - p);
+		strcat(crntp, "?=");
+		crntp += 2;
+		was_encoded = 1;
+	    }
+	    *crntp = 0; /* paranoia */
+	    p = q;
+	    continue;
+	}
+
+	/* fit into a full line? */
+	if (l <= ENCODELINELIMIT - prefixlen &&
+	    !all_white(output, linep, crntp)) {
+	    new_line(&output, &linep, &crntp, &endp, outlen, prefixlen);
+	    goto cp_again;
+	}
+
+	/* split to fit in lines in encoded form */
+	jp7savep = NULL;
+	while (p < q) {
+	    if (jp7savep) { /* restore saved chars */
+		memmove(jp7savep, savedstr, 3);
+		if (is4) { p = jp7savep - 4; memmove(p, JP7_SEQ1, 4);}
+		else { p = jp7savep - 3; memmove(p, JP7_SEQ, 3);}
+		jp7savep = NULL;
+		was_encoded = -1; /* paranoia */
+	    }
+
+	    if (left_in_ln < min64len + 4)
+		new_line(&output, &linep, &crntp, &endp, outlen, prefixlen);
+	    l = strbase64(left_in_ln - min64len);
+	    if (p + l > q) l = q - p;
+
+	    /* the line has at least space for 3 bytes */
+	    if (!jp7 && !is8) {
+		/* just split at maximum length */
+	    } else if (jp7) {
+		/* prevent splittig at the middle of jp7 sequence pair. */
+		/* Don't warry about modifing a give string (*value), */
+		/* since it will be freed just before return */
+		int i;
+		for (i=jp7_cnt-1; i>=0 ; i--) {
+		    if (jp7_pair[i].end <= p) break; /* short cut */
+		    /* check `p + l' falls inside of jp7 sequence pair */
+		    if (jp7_pair[i].bgn < p + l && p + l < jp7_pair[i].end) {
+			int jl;
+			is4 = jp7_pair[i].is4;
+			isB = jp7_pair[i].isB;
+			
+			jl = (p + l - (jp7_pair[i].bgn + 3 + is4) - 3)/2;
+			if (jl < 1) {
+			    /* back off to sequence head */
+			    l = jp7_pair[i].bgn - p;
+			    break;
+			}
+			/* split at the middle of jp7 string */
+			jp7savep = jp7_pair[i].bgn + 3 + is4 + 2*jl;
+			l = jp7savep + 3 - p;
+			memmove(savedstr, jp7savep, 3);
+			memmove(jp7savep, isB?JP7_ENDB:JP7_ENDJ, 3);
+			break;
+		    }
+		}
+	    } else /* is8 */ {
+		/* prevent splitting at the middle of multi-byte char */
+		if (!strcasecmp(charset, "UTF-8")) {
+		    while (l > 0 && ((*(p + l) & 0xc0) == 0x80))
+			l--;
+		} else if (!strcasecmp(charset, "EUCJP") &&
+			   (*(p + l - 1) & 0x80)) { /* middle of multi-byte? */
+		    int i = 0, j = 0;
+		    while ((i += j) < l) {
+			if ((*(p+i) & 0xff) == 0x8f) j = 3; /* SS3 */
+			else if (*(p+i) & 0x80) j = 2; /* 1st or SS2 */
+			else j = 1;
+		    }
+		    l = i - j;
+		}
+	    }
+
+	    if (l <= 0) {
+		if (all_white(output, linep, crntp)) {
+		    inform("Internal error: base64 enconding can't fit in a line");
+		    return 1;
+		}
+		/* remaining space is not enought */
+		new_line(&output, &linep, &crntp, &endp, outlen, prefixlen);
+		continue;
+	    }
+
+	    crntp += snprintf(crntp, left_in_ln, "=?%s?B?", charset);
+	    if (writeBase64raw((unsigned char *) p, l,
+			       (unsigned char *) crntp) != OK) {
+		inform("Internal error: base64 encoding of header failed");
+		return 1;
+	    }
+	    crntp += base64len(l);
+	    strcat(crntp, "?=");
+	    crntp += 2;
+	    *crntp = 0; /* paranoia */
+	    p += l;
+	}
+	was_encoded = 1;
+    }
+
+#undef left_in_ln
+
+    if (endp - crntp < 2) expand_line(&output, &crntp, &endp, 2);
+    strcat(crntp, "\n");
+    free(*value);
+    *value = output;
+    return 0;
+}
+
+/*
  * Encode our specified header (or field) using base64.
  *
  * This is a little easier since every character gets encoded, we can
@@ -325,6 +672,17 @@
     int outlen = 0, numencode, curlen;
     char *output = NULL, *p = *value, *q = NULL, *linestart = NULL;
 
+    static bool once_done = false; /* not determined */
+    static bool atom_wise = false;
+
+    if (!once_done) {
+	char *cp = context_find("encode_atom_wise");
+	atom_wise = cp &&  strcasecmp (cp, "enable") == 0;
+	once_done = true;
+    }
+    if (atom_wise)
+	return field_encode_base64_atom_wise(name, value, charset);
+
     /*
      * Skip over any leading white space.
      */
@@ -825,6 +1183,12 @@
     *specialchars = 0;
 
     for (; *string != '\0'; string++) {
+        char *q;
+        if (jp7_end_seq(string, q) || jp7_end_seq1(string, q)) {
+            (*eightbitchars) += q + 3 - string;
+            string = q + 3 - 1;
+            continue;
+        }
 	if ((isascii((unsigned char) *string))) {
 	    (*asciilen)++;
 	    /*
--- sbr/fmt_rfc2047.c-ORIG	2022-02-28 07:52:25.575387000 +0900
+++ sbr/fmt_rfc2047.c	2022-03-11 20:38:55.577143000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* fmt_rfc2047.c -- decode RFC-2047 header format 
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -60,7 +62,35 @@
 /* Check if character is linear whitespace */
 #define is_lws(c)  ((c) == ' ' || (c) == '\t' || (c) == '\n')
 
+/*
+ * Decode a base64 quad charaters
+ * -- returns number of bytes filled in *dst
+ * NOTE: src and dst can be a same string
+ */
 
+int
+decode_b64q(char *src, char *dst)
+{
+    int c1, c2, c3, c4;
+
+    if (!*src || !dst) return -1;
+    if (!strncmp(src, "====", 4)) return 0;
+
+    if ((c1 = char64(src[0])) == -1) return -1;
+    if ((c2 = char64(src[1])) == -1) return -1;
+    dst[0] = (c1 << 2) | (c2 >> 4);		/* 6 + 2 */
+    dst[1] = 0;
+
+    if ((c3 = char64(src[2])) == -1) return 1;
+    dst[1] = ((c2 & 0xf) << 4) | (c3 >> 2);	/* 4 + 4 */
+    dst[2] = 0;
+
+    if ((c4 = char64(src[3])) == -1) return 2;
+    dst[2] = ((c3 & 0x3) << 6) | c4;		/* 2 + 6 */
+    dst[3] = 0;
+    return 3;
+}
+
 /*
  * Decode the string as a RFC-2047 header field
  */
@@ -85,6 +115,27 @@
     if (!str)
 	return -1;
 
+#ifdef HAVE_ICONV
+    { /* take care of old JUNET mail headers, which have raw ESC sequences */
+	char *p;
+	char *ib, *ob;
+	size_t il, ol;
+	if (!( jp7_bgn_seq(str, p) || jp7_bgn_seq1(str, p) ))
+	    goto none_junet;
+	/* for old junet mail */
+	if ((cd = iconv_open(dest_charset ? dest_charset : get_charset(),
+			     "iso-2022-jp")) == (iconv_t)-1)
+	    goto none_junet;
+	ib = str; il = strlen(str);
+	ob = dst, ol = dstlen-1;
+	iconv(cd, &ib, &il, &ob, &ol);
+	dst[dstlen-1-ol] = '\0';
+	iconv_close(cd);
+	return dstlen-1-ol;
+    }
+ none_junet:
+#endif
+
     /*
      * Do a quick and dirty check for the '=' character.
      * This should quickly eliminate many cases.
@@ -279,6 +330,17 @@
 		}
 	    } else {
 		/* base64 */
+#if 1
+		char buffer[4];
+		int i,j;
+
+		pp = startofmime;
+		while (pp < endofmime) {
+		    if ((i = decode_b64q(pp, buffer)) <= 0) break;
+		    pp += 4;
+		    for (j=0; j<i; j++) ADDCHR2(buffer[j]);
+		}
+#else
 		int c1, c2, c3, c4;
 		c1 = c2 = c3 = c4 = -1;
 
@@ -319,6 +381,7 @@
 			pp++;
 		    }
 		}
+#endif
 	    }
 
 #ifdef HAVE_ICONV
--- sbr/fmt_rfc2047.h-ORIG	2022-02-28 07:52:25.598742000 +0900
+++ sbr/fmt_rfc2047.h	2022-02-28 07:52:25.601330000 +0900
@@ -24,3 +24,12 @@
  * is used.
  */
 ssize_t decode_rfc2047(char *, char *, size_t, const char *);
+
+/*
+ * Decode a base64 quad characters
+ * src          - points at first byte of base64 string
+ * dst          - points at first byte of the result, 4-byte long at least
+ *
+ * Return number of bytes filled into dst
+ */
+int decode_b64q(char *src, char *dst);
--- sbr/fmt_scan.c-ORIG	2022-02-28 07:52:25.604012000 +0900
+++ sbr/fmt_scan.c	2022-03-21 23:33:33.623308000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* fmt_scan.c -- format string interpretation
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -23,6 +25,7 @@
 #include "fmt_scan.h"
 #include "utils.h"
 #include "unquote.h"
+#include "check_charset.h"
 
 #ifdef HAVE_SYS_TIME_H
 # include <sys/time.h>
@@ -149,9 +152,20 @@
     int w;
     wchar_t wide_char;
     char *altstr = NULL;
+    static bool once_done = false; /* not determined */
+    static bool do_wcwidth_fix = false;
+#if 0
+    bool is_eucjp = strcasecmp(get_charset(), "eucJP") == 0;
+    bool is_utf8 = strcasecmp(get_charset(), "UTF-8P") == 0;
 #endif
+#endif
     char *sp;          /* current position in source string */
 
+    if (!once_done) {
+	char *cp = context_find("wcwidth_fix");
+	do_wcwidth_fix = cp && (strcasecmp(cp, "enable") == 0);
+	once_done = true;
+    }
     /* get alignment */
     rjust = false;
     if ((remaining = wid) < 0) {
@@ -188,6 +202,18 @@
 	    }
 
 	    w = wcwidth(wide_char);
+	    /* wcwidth() is buggy for some symbols; need to fix LC_CTYPE data */
+	    if (do_wcwidth_fix) {
+		if (((w == -1) || (w == 1)) && (wide_char & ~0x0ff))
+		    w = 2;
+#if 0
+		/* check halfwidth katakana */
+		if (is_eucjp && (wide_char & ~0x0ff) == 0x08e00)
+		    w = 1;
+		else if (is_utf8 && 0xff61 <= wide_char && wide_char <= 0xff9f)
+		    w = 1;
+#endif
+	    }
 
 	    /* If w > remaining, w must be positive. */
 	    if (w > remaining) {
@@ -257,7 +283,18 @@
     int srclen;
     wchar_t rune;
     int w;
+    static bool once_done = false; /* not determined */
+    static bool do_wcwidth_fix = false;
+#if 0
+    bool is_eucjp = strcasecmp(get_charset(), "eucJP") == 0;
+    bool is_utf8 = strcasecmp(get_charset(), "UTF-8") == 0;
+#endif
 
+    if (!once_done) {
+	char *cp = context_find("wcwidth_fix");
+	do_wcwidth_fix = cp && (strcasecmp(cp, "enable") == 0);
+	once_done = true;
+    }
     if (!deja_vu) {
         deja_vu = true;
 
@@ -303,6 +340,18 @@
             squash = false;
 
         w = wcwidth(rune);
+	/* wcwidth() is buggy for some symbols; need to fix LC_CTYPE data */
+	if (do_wcwidth_fix) {
+	    if (((w == -1) || (w == 1)) && (rune & ~0x0ff))
+		w = 2;
+#if 0
+	    /* check halfwidth katakana */
+	    if (is_eucjp && (rune & ~0x0ff) == 0x08e00)
+		w = 1;
+	    else if (is_utf8 && 0xff61 <= rune && rune <= 0xff9f)
+		w = 1;
+#endif
+	}
         if (w == -1) {
             rune = L'?';
             w = wcwidth(rune);
--- sbr/mf.c-ORIG	2021-05-23 08:03:06.473966000 +0900
+++ sbr/mf.c	2021-05-23 08:03:06.477036000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mf.c -- mail filter subroutines
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -532,6 +534,8 @@
     /* buffer should be at least BUFSIZ bytes long */
     int i, gotat = 0;
     char c, *bp;
+    bool has_iso_2022_jp = false;
+    char *q;
 
 /* Add C to the buffer bp. After use of this macro *bp is guaranteed to be within the buffer. */
 #define ADDCHR(C) do { *bp++ = (C); if ((bp - buffer) == (BUFSIZ-1)) goto my_lex_buffull; } while (0)
@@ -579,6 +583,14 @@
 			    : mh_xstrdup(buffer);
 			return my_lex (buffer);
 		    }
+		    continue;
+	        case '\033':	/* take care of iso-2022-jp string */
+		    ADDCHR(c);
+		    if ( jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q) ) {
+			while (cp < q + 3) ADDCHR(*cp++);
+			has_iso_2022_jp = true;
+		    }
+		    continue;
 	    }
     }
 
@@ -603,6 +615,13 @@
 		    ADDCHR(c);
 		    *bp = 0;
 		    return last_lex = LX_QSTR;
+		case '\033':    /* take care of iso-2022-jp string */
+		    ADDCHR(c);
+		    if ( jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q) ) {
+			while (cp < q + 3) ADDCHR(*cp++);
+			has_iso_2022_jp = true;
+		    }
+		    continue;
 	    }
     }
     
@@ -626,7 +645,14 @@
 		case ']': 
 		    ADDCHR(c);
 		    *bp = 0;
-		    return last_lex = LX_DLIT;
+		    return (last_lex = has_iso_2022_jp?LX_QSTR:LX_DLIT);
+		case '\033':    /* is this need? take care of iso-2022-jp string */
+		    ADDCHR(c);
+		    if ( jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q) ) {
+			while (cp < q + 3) ADDCHR(*cp++);
+			has_iso_2022_jp = true;
+		    }
+		    continue;
 	    }
     }
     
@@ -636,7 +662,11 @@
 	if (c == special[i].lx_chr)
 	    return last_lex = special[i].lx_val;
 
-    if (iscntrl ((unsigned char) c))
+    if ( (c == '\033') && (jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q)) ) {
+	/* take care of iso-2022-jp string */
+	while (cp < q + 3) ADDCHR(*cp++);
+	has_iso_2022_jp = true;
+    } else if (iscntrl ((unsigned char) c))
 	return last_lex = LX_ERR;
 
     for (;;) {
@@ -645,6 +675,13 @@
 	for (i = 0; special[i].lx_chr != 0; i++)
 	    if (c == special[i].lx_chr)
 		goto got_atom;
+	if ( (c == '\033') && (jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q)) ) {
+	    /* take care of iso-2022-jp string */
+	    ADDCHR(c);
+	    while (cp < q + 3) ADDCHR(*cp++);
+	    has_iso_2022_jp = true;
+	    continue;
+	}
 	if (iscntrl ((unsigned char) c) || isspace ((unsigned char) c))
 	    break;
 	ADDCHR(c);
@@ -657,6 +694,7 @@
     *bp = 0;
     last_lex = !gotat || cp == NULL || strchr(cp, '<') != NULL
 	? LX_ATOM : LX_AT;
+    if (has_iso_2022_jp) last_lex = LX_QSTR;
     return last_lex;
 
  my_lex_buffull:
--- sbr/unquote.c-ORIG	2018-04-12 23:11:55.000000000 +0900
+++ sbr/unquote.c	2021-05-10 09:49:51.090063000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* unquote.c -- Handle quote removal and quoted-pair strings on
  * RFC 2822-5322 atoms.
  *
@@ -22,9 +24,17 @@
 {
     int n = 0;	/* n is the position in the input buffer */
     int m = 0;	/* m is the position in the output buffer */
+    char *q;
 
     while ( input[n] != '\0') {
 	switch ( input[n] ) {
+	case '\033':
+	    output[m++] = input[n++];
+	    if ( jp7_end_seq(&input[n-1], q) || jp7_end_seq1(&input[n-1], q) ) {
+		while (&input[n] < q + 3)
+		    output[m++] = input[n++];
+	    }
+	    break;
 	case '\\':
 	    n++;
 	    if ( input[n] != '\0')
--- sbr/utils.c-ORIG	2021-05-25 23:02:00.339298000 +0900
+++ sbr/utils.c	2021-05-25 23:02:00.348916000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* utils.c -- various utility routines
  *
  * This code is Copyright (c) 2006, by the authors of nmh.  See the
@@ -587,10 +589,13 @@
     /* Allow the user to set a locale in their profile.  Otherwise, use the
        "" string to pull it from their environment, see setlocale(3). */
     if ((locale = context_find ("locale")) == NULL) {
-        locale = "";
+	if ( (((locale = getenv("LANG")) == NULL) || (*locale == '\0')) &&
+	     (((locale = getenv("LC_ALL")) == NULL) || (*locale == '\0')) &&
+	     (((locale = getenv("LC_CTYPE")) == NULL) || (*locale == '\0')) )
+	    locale = "ja_JP.eucJP";
     }
 
-    if (! setlocale (LC_ALL, locale)) {
+    if (! setlocale (LC_CTYPE, locale)) {
         inform("setlocale failed, check your LC_ALL, LC_CTYPE, and LANG "
 	    "environment variables, continuing...");
     }
@@ -618,7 +623,7 @@
         const float old_version =
             context_version  &&  has_prefix(context_version, "nmh-")
             ?  strtof (context_version + 4, NULL)
-            :  99999999;
+            :  99999999.0;
 
         if (context_version == NULL  ||  old_version < current_version) {
             context_replace ("Version", "nmh-" VERSION);
--- uip/mhbuildsbr.c-ORIG	2021-11-12 14:06:44.671667000 +0900
+++ uip/mhbuildsbr.c	2022-03-13 07:56:50.541124000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mhbuildsbr.c -- routines to expand/translate MIME composition files
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -1395,6 +1397,7 @@
     struct text *t = NULL;
     FILE *in = NULL;
     CE ce = &ct->c_cefile;
+    bool has_iso_2022_jp = false, is_text = false;
 
     /*
      * handle multipart by scanning all subparts
@@ -1433,6 +1436,7 @@
      */
 
     if (ct->c_type == CT_TEXT) {
+	is_text = true;
 	t = (struct text *) ct->c_ctparams;
 	if (t->tx_charset == CHARSET_UNSPECIFIED) {
 	    checknul = true;
@@ -1516,6 +1520,14 @@
 	     */
 	    for (cp = bufp; (check8bit || checknul) &&
 					cp < bufp + gotlen; cp++) {
+		char *q;
+	        if (is_text && (jp7_end_seq(cp, q) || jp7_end_seq1(cp, q)) ) {
+		    contains8bit = true;	/* this is fake! */
+		    check8bit = false;	/* no need to keep checking */
+		    has_iso_2022_jp = true;
+		    cp = q + 3 - 1;
+		    continue; /* may not need */
+		}
 		if (!isascii ((unsigned char) *cp)) {
 		    contains8bit = true;
 		    check8bit = false;	/* no need to keep checking */
@@ -1599,6 +1611,12 @@
             else
                  ct->c_encoding = CE_7BIT;
 
+	    if (is_text && has_iso_2022_jp) {
+		ct->c_encoding = CE_7BIT; /* force 7bit */
+		CI ci = &ct->c_ctinfo;
+		replace_param(&ci->ci_first_pm, &ci->ci_last_pm,
+			      "charset", "iso-2022-jp", 0);
+	    }
 	    break;
 
 	case CT_APPLICATION:
@@ -1698,7 +1716,20 @@
      * the Content-Type line.
      */
     if (ci->ci_comment) {
-	snprintf (buffer, sizeof(buffer), "(%s)", ci->ci_comment);
+	/* comment can have encoded-word -- rfc2047 */
+	int i = 0;
+	char *p = ci->ci_comment;
+	if (encode_rfc2047("", &ci->ci_comment, 0, NULL))
+	    adios(NULL, "Unable to encode comment");
+	if ((p != ci->ci_comment) &&
+	    (i = strlen(ci->ci_comment)) > 0 &&
+	    ci->ci_comment[i-1] == '\n' ) {
+	    ci->ci_comment[i-1] = '\0';
+	    i = 1; /* to skip leading space */
+	} else
+	    i = 0;
+
+	snprintf (buffer, sizeof(buffer), "(%s)", ci->ci_comment+i);
 	if (len + 1 + (cc = 2 + strlen (ci->ci_comment)) >= CPERLIN) {
 	    vp = add ("\n\t", vp);
 	    len = 8;
--- uip/mhlistsbr.c-ORIG	2021-05-23 08:03:06.486211000 +0900
+++ uip/mhlistsbr.c	2022-03-06 20:52:56.997588000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mhlistsbr.c -- routines to list information about the
  *             -- contents of MIME messages
  *
@@ -17,6 +19,7 @@
 #include "mhlistsbr.h"
 #include "sbr/utils.h"
 #include "mhmisc.h"
+#include "sbr/fmt_rfc2047.h"
 
 /*
  * static prototypes
@@ -178,8 +181,12 @@
     /* print Content-Description */
     if (ct->c_descr) {
 	char *dp;
+	char buf0[NMH_BUFSIZ];
 
-	dp = cpytrim (ct->c_descr);
+	if (decode_rfc2047(ct->c_descr, buf0, NMH_BUFSIZ, NULL) > 0)
+	    dp = cpytrim (buf0);
+	else
+	    dp = cpytrim (ct->c_descr);
 	if (verbose)
 	    printf (LSTFMT2d1v, dp);
 	else
@@ -203,8 +210,12 @@
 	 */
 	if (ci->ci_comment) {
 	    char *dp;
+	    char buf0[NMH_BUFSIZ];
 
-	    dp = cpytrim (ci->ci_comment);
+	    if (decode_rfc2047(ci->ci_comment, buf0, NMH_BUFSIZ, NULL) > 0)
+		dp = cpytrim (buf0);
+	    else
+		dp = cpytrim (ci->ci_comment);
 	    snprintf (buffer, sizeof(buffer), "(%s)", dp);
 	    free (dp);
 	    printf (LSTFMT2d2, buffer);
--- uip/mhlsbr.c-ORIG	2021-11-12 09:50:15.442161000 +0900
+++ uip/mhlsbr.c	2022-03-21 23:36:34.188865000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mhlsbr.c -- main routines for nmh message lister
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -42,6 +44,7 @@
 #include "sbr/terminal.h"
 #include "sbr/path.h"
 #include "sbr/globals.h"
+#include "sbr/context_find.h"
 
 /*
  * MAJOR BUG:
@@ -1297,8 +1300,16 @@
     bool cchdr;
     char *cp;
     const int utf8 = strcasecmp(get_charset(), "UTF-8") == 0;
+    static bool once_done = false; /* not determined */
+    static bool force_8bit = false;
 
-    if (! utf8  &&  flag != BODYCOMP) {
+    if (!once_done) {
+	char *cp = context_find("force_8bit");
+	force_8bit = cp &&  strcasecmp (cp, "enable") == 0;
+	once_done = true;
+    }
+
+    if (! force_8bit && ! utf8  &&  flag != BODYCOMP) {
         /* Don't print 8-bit bytes in header field values if not in a
            UTF-8 locale, as required by RFC 6532. */
 	c1->c_flags |= FORCE7BIT;
--- uip/mhparse.c-ORIG	2022-03-14 10:41:57.026529000 +0900
+++ uip/mhparse.c	2022-03-14 10:41:57.222650000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mhparse.c -- routines to parse the contents of MIME messages
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -748,9 +750,23 @@
      */
     if (magic && *cp == '[') {
 	ct->c_descr = ++cp;
+#if 1
+	{   char *cp0 = cp, *dp0;
+	    dp = cp - 1;
+	    while((c = *cp0)) {
+		if (c == ']') dp = cp0;
+		else if ((c == '\033') &&
+			 (jp7_end_seq(cp0, dp0) || jp7_end_seq1(cp0, dp0)) ) {
+		    cp0 = dp0 + 3 - 1;
+		}
+		cp0++;
+	    }
+	}
+#else
 	for (dp = cp + strlen (cp) - 1; dp >= cp; dp--)
 	    if (*dp == ']')
 		break;
+#endif
 	if (dp < cp) {
 	    inform("invalid description in message %s", ct->c_file);
 	    ct->c_descr = NULL;
@@ -775,9 +791,23 @@
      */
     if (magic && *cp == '{') {
         ++cp;
+#if 1
+	{   char *cp0 = cp, *dp0;
+	    dp = cp - 1;
+	    while((c = *cp0)) {
+		if (c == '}') dp = cp0;
+		else if ((c == '\033') &&
+			 (jp7_end_seq(cp0, dp0) || jp7_end_seq1(cp0, dp0)) ) {
+		    cp0 = dp0 + 3 - 1;
+		}
+		cp0++;
+	    }
+	}
+#else
 	for (dp = cp + strlen (cp) - 1; dp >= cp; dp--)
 	    if (*dp == '}')
 		break;
+#endif
 	if (dp < cp) {
 	    inform("invalid disposition in message %s", ct->c_file);
 	    ct->c_dispo = NULL;
@@ -976,6 +1006,15 @@
 		break;
 	    *bp++ = c;
 	    continue;
+
+	case '\033':	/* take care of iso-2022-jp string */
+	    *bp++ = c;
+	    {   char *q; 
+		if ( jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q) ) {
+		    while (cp < q + 3) *bp++ = *cp++;
+		}
+		continue;
+	    }
 	}
 	break;
     }
@@ -3255,6 +3294,15 @@
 		    default:
 			len++;
 			continue;
+		    case '\033':    /* take care of iso-2022-jp string */
+			len++;
+			{   char *q; 
+			    if ( jp7_end_seq(cp-1, q) || jp7_end_seq1(cp-1, q) ) {
+				len += q + 3 - cp;
+				cp = q + 3;
+			    }
+			}
+			continue;
 		    }
 		    break;
 		}
@@ -3270,6 +3318,14 @@
 	    if (*dp == '"') {
 		int i;
 		for (cp = dp + 1, vp = valptr, i = 0; i < len; i++) {
+		    char *q;
+		    if ( jp7_end_seq(cp, q) || jp7_end_seq1(cp, q) ) {
+			strncpy(vp, cp, q + 3 - cp);
+			vp += q + 3 - cp;
+			i += q + 3 - cp - 1;
+			cp = q + 3;
+			continue;
+		    }
 		    if (*cp == '\\') {
 			cp++;
 		    }
@@ -3282,6 +3338,20 @@
 	    }
 
 	    valptr[len] = '\0';
+#if 1
+	    /* check for illegal use of rfc2047 encoding
+	     * rfc2231 specifies encoding of attribute's value as above.
+	     * when fixing, do not apply.
+	     */
+	    if (strcmp(invo_name, "mhfixmsg")) {
+		char buf0[NMH_BUFSIZ];
+		if (decode_rfc2047(valptr, buf0, NMH_BUFSIZ, NULL) > 0) {
+		    free(valptr);
+		    valptr = mh_xstrdup(buf0);
+		    charset = mh_xstrdup(get_charset());
+		}
+	    }
+#endif
 	}
 
 	/*
@@ -3632,6 +3702,33 @@
     maxfit = CPERLIN - (12 + len + strlen(indexchar));
     if ((eightbit && index == 0) || contains8bit(start, start + maxfit)) {
 	*encode = 1;
+    }
+    /* check iso-2022-jp */
+    {
+	char *p, *q, *r;
+	if (index == 0) {
+	    /* always encode in 1st section */
+	    if (jp7_bgn_seq(pm->pm_value, q) || jp7_bgn_seq1(pm->pm_value, q) ) {
+		*encode = 1;
+		if (! pm->pm_charset)
+		    pm->pm_charset = mh_xstrdup("iso-2022-jp");
+	    }
+	} else {
+	    /* encode if an intersection of output region and
+	     * jp7 sequence pair is not empty */
+	    /* it is ok to split at the middle of jp7 sequence pair */
+	    p = pm->pm_value;
+	    while ( (jp7_bgn_seq(p, q) && jp7_end_seq(q, r)) ||
+		    (jp7_bgn_seq1(p, q) && jp7_end_seq1(q, r)) ) {
+		if (start + maxfit <= q) break; /* short cut */
+		if ( (start <= q + 3 - 1 && q < start + maxfit) ||
+		     (start <= r + 3 - 1 && r + 3 < start + maxfit) ) {
+		    *encode = 1;
+		    break;
+		}
+		p = r + 3;
+	    }
+	}
     }
 
     len++;	/* Add in equal sign */
--- uip/mhshowsbr.c-ORIG	2021-05-25 23:02:00.362576000 +0900
+++ uip/mhshowsbr.c	2021-05-25 23:02:00.366710000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* mhshowsbr.c -- routines to display the contents of MIME messages
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -1147,6 +1149,11 @@
 			goto iconv_start;
 		    }
 		    if (errno == EINVAL) {
+			if (outbytes_before == outbytes) {
+			    ib++; inbytes--; /* skip it */
+			    *ob++ = '?'; outbytes --;
+			    goto iconv_start;
+			}
 			/* middle of multi-byte sequence */
 			if (write (fd, dest_buffer, outbytes_before - outbytes) < 0) {
 			    advise (dest, "write");
--- uip/popsbr.c-ORIG	2021-05-25 23:02:00.369927000 +0900
+++ uip/popsbr.c	2021-05-25 23:02:00.372668000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* popsbr.c -- POP client subroutines
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -45,6 +47,7 @@
 {
   int status;
   bool sasl_capability = false;
+  bool utf8_capability = false;
 
     /*
      * First off, we're going to send the CAPA command to see if we can
@@ -69,6 +72,11 @@
             sasl_capability = true;
             abortcpy(server_mechs, response + 5, server_mechs_size);
         }
+ 	if (strncasecmp(response, "UTF8", 4) == 0 ||
+ 	    strncasecmp(response, "UTF8 USER", 9) == 0) {
+ 	    /* ignore the USER argument if any */
+ 	    utf8_capability = true;
+ 	}
     }
 
     if (!sasl_capability) {
@@ -76,6 +84,13 @@
 	return NOTOK;
     }
 
+    if (utf8_capability) {
+        if (command("UTF8") == NOTOK) {
+            TRUNCCPY(response, "The POP UTF8 command failed");
+            /* return NOTOK; -- ignore ! */
+	}
+    }
+ 
     return OK;
 }
 
--- uip/scansbr.c-ORIG	2021-05-09 23:57:46.000000000 +0900
+++ uip/scansbr.c	2022-03-21 23:37:20.125662000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* scansbr.c -- routines to help scan along...
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -17,9 +19,16 @@
 #include "sbr/addrsbr.h"
 #include "sbr/fmt_compile.h"
 #include "sbr/fmt_scan.h"
+#include "sbr/fmt_rfc2047.h"
 #include "h/tws.h"
 #include "sbr/utils.h"
+#include "h/mime.h"
+#ifdef HAVE_ICONV
+#include <iconv.h>
+#endif
 #include "sbr/terminal.h"
+#include "sbr/context_find.h"
+#include "sbr/check_charset.h"
 
 static struct format *fmt;
 static struct comp *datecomp;		/* pntr to "date" comp             */
@@ -44,6 +53,17 @@
 		    DIEWRERR();\
 		}
 
+/*
+ * prototypes
+ */
+static char* find_text_plain(char *, char *, int *, bool);
+static int maybe_iso_2022_jp(char *);
+static void decode_qp_str(char *);
+static void decode_b64_str(char *);
+static void char_convert(char *, char *);
+#define QP_STR  1
+#define B64_STR 2
+
 /* outnum determines how the input from inb is copied.  If positive then
  * it is the number of the message to create, e.g. for inc(1), and all
  * of the email is copied into that message, with some tweaks.  If 0,
@@ -69,7 +89,19 @@
     char name[NAMESZ];
     int bufsz;
     static int rlwidth, slwidth;
+    char csname[128], boundary[128];
+    int b64_or_qp = 0;
+    bool is_digest = false;
 
+    static bool once_done = false; /* not determined */
+    static bool scan_text_plain = false;
+
+    if (!once_done) {
+	char *cp = context_find("scan_text_plain");
+	scan_text_plain = cp &&  strcasecmp (cp, "enable") == 0;
+	once_done = true;
+    }
+
     /* first-time only initialization, which will always happen the
        way the code is now, with callers initializing *scanl to NULL.
        scanl used to be a global. */
@@ -176,6 +208,9 @@
     }
 
     /* scan - main loop */
+    csname[0] = boundary[0] = '\0';
+    b64_or_qp = 0;
+    is_digest = false;
     for (compnum = 1; ;
 	bufsz = rlwidth, state = m_getfld (&gstate, name, tmpbuf, &bufsz, inb)) {
 	switch (state) {
@@ -187,6 +222,53 @@
 		    PUTC(':');
 		    FPUTS (tmpbuf);
 		}
+		/* check text/plain, multipart/.. */
+		if (!strcasecmp(name, TYPE_FIELD)) {
+		    /* check charset specification */
+		    if (strcasestr(tmpbuf, "text/plain")) {
+			char *cs = strcasestr(tmpbuf, "charset=");
+			int i;
+			if (cs) {
+			    cs += strlen("charset=");
+			    if (*cs == '"') cs++;
+			    for (i=0; i<128-1; ++i) {
+				if ((*cs == '"') || (*cs == ';') || (*cs == ' ') ||
+				    (*cs == '\n') || (*cs == '\0')) break;
+				csname[i] = *(cs++);
+			    }
+			    csname[i] = '\0';
+			    /* advise(NULL, "charset=%s", csname); */
+			}
+		    }
+		    if (strcasestr(tmpbuf, "multipart/")) {
+			int i;
+			char *bp = strcasestr(tmpbuf, "boundary=");
+			if (bp) {
+			    bp += strlen("boundary=");
+			    boundary[0] = boundary[1] = '-';
+			    if (*bp == '"') bp++;
+			    for (i=2; i<128-1; ++i) {
+				if ((*bp == '"') ||
+				    (*bp == '\n') || (*bp == '\0')) break;
+				boundary[i] = *(bp++);
+			    }
+			    boundary[i] = '\0';
+			    /* advise(NULL, "boundary=%s", boundary); */
+			}
+			is_digest = strcasestr(tmpbuf, "multipart/digest") != NULL;
+		    }
+		}
+		/* check transfer encoding */
+		if (!strcasecmp(name, ENCODING_FIELD)) {
+		    b64_or_qp = strcasestr(tmpbuf, "quoted-printable")?QP_STR:0;
+		    b64_or_qp |= strcasestr(tmpbuf, "base64")?B64_STR:0;
+		    /* advise(NULL, "base64/quoted-printable:%d", b64_or_qp); */
+		}
+
+		/* for old JUNET mail headers, which have raw ESC sequences */
+		if (maybe_iso_2022_jp(tmpbuf))
+		    char_convert(tmpbuf, "iso-2022-jp");
+
 		/*
 		 * if we're interested in this component, save a pointer
 		 * to the component text, then start using our next free
@@ -306,6 +388,23 @@
     if (bodycomp) {
 	saved_c_text = bodycomp->c_text;
 	bodycomp->c_text = startbody;
+	/* now I can modify startbody for scan list */
+	if (startbody && scan_text_plain) {
+	    char *p;
+	    if (boundary[0] && (p=strcasestr(startbody, boundary)) &&
+		((p == startbody) || (startbody < p && p[-1] == '\n'))) {
+		startbody = find_text_plain(p, csname, &b64_or_qp, is_digest);
+		bodycomp->c_text = startbody;
+	    }
+	    if (b64_or_qp & QP_STR)
+	        decode_qp_str(startbody);
+	    if (b64_or_qp & B64_STR)
+	        decode_b64_str(startbody);
+	    if (csname[0])
+	        char_convert(startbody, csname);
+	    else if (maybe_iso_2022_jp(startbody))
+	        char_convert(startbody, "iso-2022-jp");
+	}
     }
 
     if (size)
@@ -365,4 +464,190 @@
 scan_detect_mbox_style (FILE *f)
 {
     m_unknown (&gstate, f);
+}
+
+static int
+maybe_iso_2022_jp(char *buf)
+{
+    char *p;
+
+    return buf && (jp7_bgn_seq(buf, p) || jp7_bgn_seq1(buf, p));
+}
+
+/* decode in place */
+static void
+decode_qp_str(char *buf)
+{
+    char *p;
+    int c;
+
+    if (!(p = buf)) return;
+
+    while (*buf) {
+	if ((c = *(buf++)) == '=') {
+	    int val;
+	    if (buf[0] == '\n') {
+		buf++; continue;
+	    }
+	    if ((val = decode_qp(buf[0], buf[1])) == -1) continue;
+	    *(p++) = val;
+	    buf += 2;
+	    continue;
+	}
+	/* normal characters */
+	*(p++) = c;
+    }
+    *p = '\0';
+}
+
+/* decode in place -- no strict format check */
+static void
+decode_b64_str(char *buf)
+{
+    char *p;
+    int i;
+
+    if (!(p = buf)) return;
+
+    while(*buf) {
+	if (*buf == ' ' || *buf == '\t' || *buf == '\n') { buf++; continue;}
+	if ((i = decode_b64q(buf, p)) <= 0) break;
+	p += i;
+	buf += 4;
+    }
+    *p = '\0';
+}
+
+static void
+char_convert(char *buf, char *cs)
+{
+#ifdef HAVE_ICONV
+    char lbuf[NMH_BUFSIZ];
+    char *ib, *ob;
+    size_t il, ol;
+    iconv_t ct;
+
+    if (!buf) return;
+
+    if ((ct=iconv_open(get_charset(), cs)) == (iconv_t)(-1))
+	return;
+    ib = buf; il = strlen(buf);
+    ob = lbuf; ol = NMH_BUFSIZ - 1;
+    while ((il > 0) && (ol > 0))
+	if (iconv(ct, &ib, &il, &ob, &ol) == (size_t)(-1)) {
+	    break; /* don't warry about lbuf[] being short */
+#if 0
+	    if ((errno == EILSEQ) || (errno == EINVAL)) {
+		ib++; il--;
+		*ob++ = '?'; ol--;
+	    } else
+		break;
+#endif
+	}
+    (void) iconv_close(ct);
+    if (ol < NMH_BUFSIZ - 1) {
+	strncpy(buf, lbuf, NMH_BUFSIZ-1-ol);
+	buf[NMH_BUFSIZ-1-ol] = '\0';
+    }
+#endif /* HAVE_ICONV */
+    return;
+}
+
+/* find text/plain in adhoc way
+ *	^--   boundary seperator
+ *	^[ \t] field continuetion
+ *	^$    end of field part
+ */
+static char*
+find_text_plain(char *buf, char *csp, int *bqp, bool is_digest)
+{
+    /* first line of buf[] is boundary separator */
+    char csname[128];
+    int bq;
+    bool has_text, has_encoding;
+    char *save_buf = buf;
+    char *nextp;
+
+    csname[0] = '\0';
+    bq = 0;
+    has_text = has_encoding = false;
+    nextp = buf;
+    while (nextp) {
+	buf = nextp;
+skip:
+	while (*nextp && *nextp != '\n') nextp++; /* skip to next line */
+	if (*nextp) {
+	    char *p = ++nextp;
+	    /* check field continuation */
+	    if (*nextp == ' ' || *nextp == '\t') {
+		while (*nextp == ' ' || *nextp == '\t') nextp++;
+		if (*nextp != '\n') goto skip;
+	    }
+	    nextp = p;
+	    nextp[-1] = '\0';
+	} else nextp = NULL;
+	/* line termination is replaced with null code */
+	/* boundary separator */
+	if (!strncmp(buf, "--", 2)) {
+	    csname[0] = '\0';
+	    bq = 0;
+	    has_text = has_encoding = false;
+	    if (is_digest) {
+		/* need to skip empty line */
+		while (nextp && *nextp == ' ') nextp++;
+		if (nextp && *nextp == '\n') nextp++;
+	    }
+	    continue;
+	}
+	if (*buf == '\0') {
+	    /* empty line --> end of fields */
+	    if (has_text) break;
+	    if (nextp && (nextp = strstr(nextp, "\n--"))) nextp++;
+	    continue;
+	}
+	if (!strncasecmp(buf, TYPE_FIELD ":", strlen(TYPE_FIELD ":"))) {
+	    if (strcasestr(buf, "text/plain")) {
+		char *cs = strcasestr(buf, "charset=");
+		int i;
+		if (cs) {
+		    cs += strlen("charset=");
+		    if (*cs == '"') cs++;
+		    for (i=0; i<128-1; ++i) {
+			if ((*cs == '"') || (*cs == ';') || (*cs == ' ') ||
+			    (*cs == '\n') || (*cs == '\0')) break;
+			csname[i] = *(cs++);
+		    }
+		    csname[i] = '\0';
+		    /* advise(NULL, "charset=%s", csname); */
+		    has_text = true;
+		}
+		continue;
+	    }
+	    /* skip to next part */
+	    if (nextp && (nextp = strstr(nextp, "\n--"))) nextp++;
+	    continue;
+	}
+	/* check transfer encoding */
+	if (!strncasecmp(buf, ENCODING_FIELD ":", strlen(ENCODING_FIELD ":"))) {
+	    bq = strcasestr(buf, "quoted-printable")?QP_STR:0;
+	    bq |= strcasestr(buf, "base64")?B64_STR:0;
+	    /* advise(NULL, "base64/quoted-printable:%d", bq); */
+	    has_encoding = true;
+	    continue;
+	}
+	/* don't care about other fields */
+    }
+
+    if (has_text) {
+	strcpy(csp, csname);
+	if (has_encoding) *bqp = bq;
+	if (nextp) {
+	    buf = nextp;
+	    if ((nextp = strstr(buf, "\n--"))) *nextp = '\0';
+	}
+	return buf;
+    }
+
+    *save_buf = '\0';
+    return save_buf;
 }
--- uip/whatnowsbr.c-ORIG	2022-03-07 11:13:20.118328000 +0900
+++ uip/whatnowsbr.c	2022-03-12 23:17:53.081941000 +0900
@@ -1,3 +1,5 @@
+/* -*- mode: c; c-basic-offset: 4; -*- */
+
 /* whatnowsbr.c -- the WhatNow shell
  *
  * This code is Copyright (c) 2002, by the authors of nmh.  See the
@@ -1329,6 +1331,16 @@
 	switch (m_getfld2(&gstate, name, buf, &bufsz)) {
 	case FLD:
 	case FLDPLUS:
+	    /* assuming header fields which require encoding
+	     * precede MIME-Version
+	     */
+	    {   char *q;
+		if (contains8bit(buf, NULL) ||
+		    jp7_bgn_seq(buf, q) || jp7_bgn_seq1(buf, q) ) {
+		    retval = 0;
+		    break;
+		}
+	    }
 	    if (strcasecmp(name, VRSN_FIELD) == 0) {
 		inform("Cannot use attach commands with already-"
 		       "formatted MIME message \"%s\"", drft);
